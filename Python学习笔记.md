# Python学习笔记

# 前言

**加粗**：用以重点强调；

*斜体*

> 块引用：block quoting

横线：三个短横线

---

[link](http://www.baidu.com)

[内部link](#OOP：宏伟蓝图)

```
代码块
```

`print()`









# 概述

利用机器代替人，是效率提升的一个重要手段，在测试工作中，产品测试用例的自动化执行是这个思路的非常重要的体现，我们希望测试人员能够非常好的掌握这个手段，这就是这个系列的目标：

- 对IPC自动化所需要的知识进行梳理，给大家一个清晰的路线图；
- 对关键知识点进行介绍讲解，能掌握并在工作实践中应用；

并且按照刻意练习的原则更偏重获得技能，而非仅仅获取知识（强实践、练习），并且强调在情景中学习，从工程的角度去学习。

用机器代替人，实际上的意思是让机器去为我们做一些事情，以当前的发展来看，机器擅长的往往是人不擅长的，正好可以形成互补。比如阅读一篇文章，人擅长的是理解其中的意思，但是如果要给出这篇文章中各个单词出现的频率就不是人擅长的了，而这恰恰是机器擅长的。

人有人言，兽有兽语，计算机也有自己的语言，并且我们这个伙伴性格直爽，你希望它做什么一定要告诉的清晰明确，要不它就会不知所措，可以说既聪明又笨拙，属于典型的推一下，动一下，从这个意义上来讲，程序就是一些列指令的集合，我们提前把需要计算机做的事情写下来，计算机拿到之后只需要对照这个清单一步步做下去就行了。对于一门语言来说，两方面的技能是必须的：

- 单词与语法，进而写出句子；
- 讲故事的能力：我们是通过“故事”来传递我们的观点/想法，对于计算机来说，观点就是要解决的问题。

掌握单词与语法，写出句子来，这个是基础，可以非常迅速的掌握，对于Python来说就是基础数据结构、条件语句、循环语句、模块等基础知识，以及迭代器、生成器、装饰器等进阶知识；讲故事的能力相对复杂，但是学习编程与学习写作非常类似，我们可以通过阅读理解背诵“范文”的方式来学习锻炼讲故事的能力，在编程中“文章”是指一些好的实践（项目源码）

**每个研究领域都有自己的语言和思考方式**。数学家谈论公理、积分和向量空间；心理学家谈论自我、本我和认知失调；律师谈论案发现场、侵权行为和允诺禁止反言原则。经济学家也没有什么不同。供给、需求、比较优势、消费者剩余、无谓损失等等这些术语都是经济学家语言的一部分。**乍一看，这种语言似乎有一种不必要的神秘，但是它的价值在于能够为你提供一种关于你所生活的世界的新的、有用的思考方式。**

编程语言也有自己的一些术语、概念，下面是常见的一些

## 何谓程序

程序是由一些列为了做某事而组织在一起的语句，程序可以只有一条语句，也可以有很多条。虽说有了语言，我们应该可以与计算机进行交互了，但是计算机的核心CPU只能理解机器语言：

> 000101000010101010101000100101001010101001010101010101000000111010100

机器语言与CPU硬件紧密相连（比如不同指令集的CPU），并且人理解使用起来很困难，所以需要一个媒介或者说软件能把它们变得易懂一些，把易于人理解使用的语言（所谓的高级语言）转换成计算机的机器语言，这个中间媒介就是编译器或者解释器，他们充当这个翻译转换的动作

**解释器（interpreter）**：在阅读程序代码的时候，一边解析一边执行；

**编译器（compiler）**：把整个代码文件作为一个整体，进行处理，转换为机器语言文件，后直接运行这个机器语言文件。

前面提到，程序是由单词、语句、语句结构、段落结构、故事结构等构成，在程序构建过程中，还有一些基础概念需要了解：

- 输入：从外部世界获取数据，常见的有从文件中读取，从输入设备中（鼠标、键盘、各类传感器等）获得等；
- 输出：用于展示程序运行结果，常见的方式有：显示器、存到一个文件中、音频输出等；
- 顺序执行：按照语句在代码中出现的先后顺序依次执行；
- 条件执行：通过检查条件，来控制执行或者跳过语句；
- 循环执行：重复执行某语句；
- 重用：一组指令/语句写好之后，通过给他们一个名字，从而在整个程序中都可以通过这个名字来直接使用这组语句。

对于python来说，程序是由语句构成的，而语句即可能由关键字定义，也可能由表达式构成，表达式则由操作符与操作数构成

**操作符**：包括算术操作符、比较操作符、逻辑操作符；

**操作数**：任何的变量都可以是操作数，并不一定是数字。比如列表也支持相加，或者乘以一个整数等操作；

**注释**：注释让你能够使用自然语言在程序中添加说明；**编写注释的主要目的是阐述代码要做什么，以及是如何做的**。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了，当然你总是可以通过研究代码来确定各个部分的工作原理，但通过写注释，以清晰的自然语言对解决方案进行概述，可节省很多时间。做为新手，最值得养成的习惯之一是在代码中编写清晰、简洁的注释。

## 错误与调试

**语法错误**：程序中包含非法的python代码时就会导致语法错误；

**逻辑错误：**从语法上代码是合法的，但是结果并不符合预期。

编写程序时，编辑器会以各种方式突出程序的不同部分，例如它知道`print`是一个函数，因此将其显示为蓝色等等，这个功能被称为**语法突出**；在编写脚本的时候，比如你输入`print("hello world")`实际上python并不关心你里面的内容是什么，它只是看到print那么就按照print的规定把动作做了。



## 变量

每个变量都存储了一个值---与变量相关联的信息。在python中使用变量的时候，需要遵守一些**规则**和**指南**。违反这些规则将导致错误，而指南旨在让编写的代码更容易理解。





# 常见数据类型

大多数程序都定义并收集某种数据，然后使用它们来做有意义的事情。就像我们不能把所有物品都称为“东西”一样，在程序中对数据进行分类大有裨益。python常见的数据类型有：

![image-20200908065252063](/Users/wangguangli/Library/Application Support/typora-user-images/image-20200908065252063.png)

## 字符串str

*字符串*就是一系列字符。在python中，用**引号**（单、双、三引号）括起来的都是字符串

```python
'This is a string'
"This is also a string"
'''This is also also a string'''
```

数据都是拿来运算的，常见的**数据运算方式有**：

- **通过特定符号直接创建数据：**比如通过引号定义字符串，通过中括号【】创建列表，通过花括号{}创建字典等；
- **通过表达式**：包括\+ \- * / 数学运算符、> < == !=等比较运算符、and or not 等逻辑运算符、in not in 存在性判定等；
- **通过函数或者方法的调用**：**方法是python可对数据执行的操作**，使用"."操作符，表示作用到数据上。比如name.title()中，name后面的句点让Python对变量name执行方法title指定的操作。每个方法后面都跟着一对括号，这是因为方法通常需要额外的信息来完成其工作。

使用字符串的一个小技巧：

```python
message = "This car an go approximately" + str(range)
message += "miles on a full charge"
```

使用上面的技巧可以有效避免每行过长的问题



##  列表list

列表是由一系列按照特定顺序排列的元素组成，你可以将任何东西加入到列表中，其中的元素之间可以没有任何关系。列表是可变、有序的，列表的有序是只数据存储的有序，并非指数据本身内容的有序，列表中的数据之间在编程语言语法的层面上是没有任何关系的。

- 可以通过索引方式访问列表的一个或者多个数据：[ ]
- 索引是从0开始，负号“-”号表示从后向前；
- 可以使用方法：append(),insert()向列表中增加数据；
- 可以使用del语句、pop方法或者remove方法从列表中删除数据；
- 组织列表：可以使用sort方法对列表进行永久排序，使用sorted函数得到列表排序的副本；可以使用reverse方法对列表反转；



## 字典dict

字典是一系列键值对，每个健都与一个值相关联，是python中唯一的映射类型。字典是一种动态的结构，可以随时在其中添加键值对，不过python不关心键值对的添加顺序，而只关心健和值之间的关联关系（可变，无序）。键值对之间以逗号分隔。

```python
favorite_languages = {
  'jen': 'python',
  'sarah': 'c',
  'edward': 'ruby',
  'phil': 'python',
}

print("sarah's favorite language is " +
     favorite_languages['sarah'].title() +
      "."
     )
```

上看的例子除了演示了如何定义字典（特别是多行的情况下，在最后一个键值对后仍推荐增加一个逗号分隔符），以及如何将较长的print语句分成多行。

字典的常用方法：

- items（），keys（），values（）；
- setdefault（），get（）？



## 函数

函数是带名字的代码块，使用def语句定义。函数是实现DRY（Don‘t Repeat Youself）的重要手段。与函数相关的一些概念：

- 形参与实参；
- 位置参数与默认参数；
- 传递任意数量的参数：形参类似*toppings中的星号让python创建一个名为toppings的空元组，并将收到的所有值都装到这个元组中，即使只传递了一个实参，也会被封装到元组中；
- 形参类似**user_info会让python创建一个名为user_info的空字典，并将收到的所有名称-值都封装到这个字典中，这样在函数体中就可以像访问其他字典一样访问user_info

每个函数都应该只负责一项具体的工作，不要让函数做太多内容，如果需要那么建议分成多个函数。

编写函数的时候，需要牢记几个细节：

1. 应给函数指定描述性名称，且只在其中使用小写字母和下划线；
2. 每个函数都应该包含简要地描述其功能的注释，该注释应该紧跟在函数定义后面，并采用文档字符串格式；
3. 给形参指定默认值的时候等号两边不要留空格，对于函数调用中的关键字参数，也应该遵循这种约定；
4. 多个函数之间使用两个空行将相邻的函数分开



## 类

在Python中使用**class 语句**可以实现一种新的对象**类**，它是python面向对象程序设计的主要工具。OOP是一种编程范式，使用类需要一些预先的规划，因此相比于采用战术模式工作的人（时间有限），采用战略模式工作的人（做长期产品开发）对类会更感兴趣一些。面向对象编程是最有效的软件编写方法之一。在面向对象编程中，你编写表示现实世界中的事物和情景的类，并基于这些类来创建对象。编写类时，你定义一大类对象都有的通用行为，基于类创建对象时，每个对象都自动具备这种通用行为，然后可根据需要赋予每个对象独特的个性。

从更具体的编程角度来看，类是Python程序的组成单元，就像函数与模块一样：**是封装数据和逻辑的另外一种方式**。与模块有点像，类也定义了新的命名空间，但是它有3个独特之处：

- 多重实例：类本质上是产生对象的工厂（我觉得模板更合适）；
- 继承：我们可以在类的外部编写子类，来重新定义父类的属性从而进行扩展；
- 运算符重载：通过定义特定的协议方法，类可以定义对象来响应在内置类型上的一些运算。

**从本质上来讲，Python的OOP机制主要依托于两个基础：**

- **一个特殊的函数第一位参数（来接收调用主体）；**
- **继承属性搜索**

OOP不仅仅是一门技术，更是一种经验。Python中大多数OOP的故事，都可简化成如下表达式：

*object.attribute*

当我们对class语句产生的对象使用这种方式时，这个表达式会在Python中启动一次搜索：搜索对象链接的类树，来寻找attribute首次出现的类，用自然语言描述如下：

> 找出attribute首次出现的地方，先搜索object，然后是该对象之上的所有类，由下往上，由左到右。

换句话说**属性访问就是搜索类树而已**。我们称这种搜索为**继承**，因为树中较低位置的对象继承了树中位置较高的对象所拥有的属性。继承就是“**爬树**”。

![image-20200616072544715](/Users/wangguangli/Library/Application Support/typora-user-images/image-20200616072544715.png)



上图展示了一棵包含了5个对象的类树：3个类对象（C1、C2、C3）和两个实例对象（I1、I2）。

假设我们创建了上图的类树之后，然后编写：

```python
I2.w
```

因为这是一个 *object.attribute* 表达式，所以这个代码会立即启用**继承**，它会触发上图中的搜索，确切的讲就是按照下面这个顺序搜索连接的对象：

​        I2，C1，C2，C3

**找到首个w之后就会停止搜索**（如果找不到就会报错）。此例中，直到搜索到C3时才会找到w，也就是说，通过自动搜索，I2.w会解析为C3.w。用OOP的术语来说，I2从C3继承了属性w。

如果I2.w引用时一个函数调用，其实际的含义将会是“调用C3.w函数来处理I2”，也就是说Python将会自动将I2.w( )调用映射为C3.w(I2)（同时传入该实例作为继承的函数的第一位参数）。每当我们以这种方式调用附属于类的函数时，总会隐含着这个类的实例，这个隐含的主体或者上下文就是将其称之为面向对象模型的一部分原因：**当操作执行时，总是有个主体对象（调用的主体）**。Python把隐含的实例传入方法中特殊的第一位参数，习惯上称其为self，方法通过这个参数来处理调用的主体。例如对于Employ类的实例bob，在运行bob.giveRaise（）方法调用时会做两件事：

1. 在bobo中通过继承搜索寻找giveRaise（）方法；
2. 将bob传入找到的giveRaise方法，并赋值给self参数。

**类树的创建**：

- 每个class语句会生成一个新的类对象；
- 每次类调用时，就会生成一个新的实例对象；
- 实例自动链接到创建它们的类；
- 类链接到其父类的方式是，将父类列在class头部的括号内；括号中从左到右的顺序会决定树中的次序。

super（）是一个特殊的函数，帮助python将父类与子类关联起来，我们可以在子类的方法中调用super（），从而访问父类，类似如下：

```python
super().__init__(make, model, year)
```



**运算符重载：**

构造函数\_\_init\_\_是运算符重载方法这一大类方法中最常用的代表。运算符重载方法的名称开头和结尾都带有双下划线，从而看起来十分特别。当能够支持这些操作的实例出现在对应的运算符旁时，Python会自动调用运行它们。运算符重载方法是可选的：如果缺省则不支持对应的运算。例如如果没有\_\_init\_\_方法，类调用将返回一个空实例，而不会将其初始化；例如要实现集合交集，类要么提供类似名为intersect的方法，要们编写名为\_\_add\_\_的方法来将“&”表达式运算符分发到处理交集所需要的逻辑。

虽然OOP会有更多细节，**不过大体而言，OOP就是在树中搜索属性和在函数中加入一个特殊的第一位参数**。



**类编码风格**

1. 类名应该使用驼峰命名法，实例名和模块名都采用小写格式，并在单词之间加上下划线；
2. 对于每个类，都应紧跟在类定义后面包含一个文档字符串，简要描述类的功能；
3. 类中可以用一个空行来分隔方法，在模块中可以用两个空行来分隔类；
4. 先编写导入标准库模块的import语句，再添加空行，然后编写导入第三方或者自己编写的模块的import语句



# 进阶

## 工厂函数/闭包函数

工厂函数，又名闭包函数、闭合函数，与普通函数相比，有如下特点：

- 它的函数体中一般会再包含函数（子函数）（1～2个），这个子函数一般来说会被做为函数值返回；
- 它有一个元组类型的\_\_closure\_\_属性，这个属性里面存储自由变量的参数对象地址，这是工厂函数机制实现的底层根本：能记住嵌套作用域里的变量的值（嵌套作用域即是LEGB中的E）。

实例：

```python
def wrapperfun(strname):
  def recorder(age):
    print('姓名： ', strname, '年龄： ', age)
  return recorder

fun1 = wrapperfun('Anna')  #自由变量为Anna
fun1(37)                   #输出为：姓名：Anna 年龄：37

fun2 = wrapperfun('Gary')
fun2(32)
```

上面的例子中wrapperfun（）既是工厂函数，它有一个参数strname，这个变量的值在函数返回后仍然被保存了下来，我们看到在调用fun1(或者fun2)的时候，这个字符串被正确输出出来了。

需要注意的是wrapperfun不是工厂函数，是wrapperfun（）是工厂函数，它被调用后返回的值的类型仍然是个函数，是它是闭包函数。

```python
print(fun1.__closure__)    #输出类似 <cell at 0x000000B49E4c8:str object at 0x00000c4974b>
```

通过上面的输出可以看到，是一个cell，里面包含str object

> 在计算机编程中，术语"自由变量"是指在函数中使用的变量，它们不是局部变量，也不是函数的参数。 [1 ](http://en.wikipedia.org/wiki/Free_variable/)术语非本地变量通常是此
> 上下文中的同义词

## 装饰器（decorator）

装饰器本质上是闭包函数，比较特别的是该闭包函数的自由变量也是一个函数。装饰器可以大大增强代码的重用性与扩展性，比如对于某一个已经写好的函数，如果我们想再进行扩展，最直接的方法当然是直接对这个函数进行修改，但这样就违反了软件工程中的开发封闭的原则：**在一个项目的多个版本迭代之间，对于已经实现的功能代码不允许修改，但可以被扩展**。装饰器就是python中专门为软件工程服务的编程方法：它可以在原有的函数之外再包一层。具体就是新创建一个函数，把原有的函数做为自由变量，在新创建的函数体内做扩展工作，并进行原有函数的调用工作（这样原函数的功能也被保存了下来）。

装饰器的编写有很多中方式，最简单、易读的方式是：**编写一个返回子函数的函数，这个子函数包裹原函数**（To write a function that returns a sub-function that wraps the original function call)



## 正则表达式

正则表达式简称为regex，是文本模式的描述方法。例如，\\d是一个正则表达式，表示一位数字字符。python中所有正则表达式的函数都在re模块中，如果要使用需要先导入这个模块。使用正在表达式的步骤：

1. 导入模块re；
2. **创建Regex对象**：通过向re.compile（）方法传入正则表达式字符串来创建Regex模式对象；
3. **匹配Regex对象**：向Regex对象的search（）方法传入要查找的字符串，如果没找到匹配的就返回None，如果找到了就会返回一个Match对象，Match对象有一个group（）方法，它返回被查找字符串中实际匹配的文本。

所以，正则表达式最核心的就是两步：**创建Regex对象、匹配Regex对象**。

